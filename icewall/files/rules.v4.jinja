{#- Please note that iptables-restore is annoyingly whitespace-sensitive and
    whitespace control is mandatory in this file. #}

{#- <-WHITESPACE NUKE-> -#}

# Generated by Salt Icewall state.
*filter

{#- set policy #}
{%- for chain in ["INPUT","FORWARD","OUTPUT"] %}
{%- set policy = salt['defaults.get']("policy:ipv4:{}".format(chain)) %}
:{{ chain }} {{ policy }} [0:0]
{%- endfor %}

{#- Allow established connections and connections from localhost #}
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

{#- set up ICMP #}
{%- set icmp_types = salt['defaults.get']('allow_icmp') %}
{%- for type in icmp_types %}
-A INPUT -p icmp --icmp-type {{ type }} -j ACCEPT
{%- endfor %}

{#- Now we apply the rules from pillar. This is annoyingly complex. We are
    trying to allow the pillar to specify mappings of allowed-ips to 
    allowed-ports in multiple different ways. ips may be specified
    as either an explicit list, or a pre-defined set, or a minion glob, or all
    at once. Ports may also be an explicit list or a pre-defined set. We build
    a list from each option given, concatenate them, and then iterate over the
    result to apply. #}

{%- for rule, settings in salt['defaults.get']('rules', {}).items() %}
{#-   Collect a list of ips allowed by this rule, as above. #}
{%-   set source_ips = settings.get('ips', []) %}
{%-   if "ipset" in settings %}
{%-     set ips = salt['defaults.get']('ipsets:' + settings.ipset, []) %}
{%-     do source_ips.extend(ips) %}
{%-   endif %}
{%-   if "minions" in settings %}
{%-     for minion in salt['mine.get'](settings.minions, 'network.interfaces').values() %}
{%-       do source_ips.append(minion['eth0']['inet'][0]['address']) %}
{%-     endfor %}
{%-   endif %}

{#-   Now collect a list of ports allowed by this rule. #}
{%-   set ports = settings.get('ports', []) %}
{%-   if 'portset' in settings %}
{%-     set portset = salt['defaults.get']('portsets:' + settings.portset, []) %}
{%-     do ports.extend(portset) %}
{%-   endif %}

{#-   If the rule specifies a particular protocol, note that too. I'd like to
      come up with a clean way to support icmp here so the top block can be
      cut, but icmp types and tcp/udp ports use different syntax. #}
{%-   set protocols = settings.get('protocols', ['tcp','udp']) %}

{#-   Now, apply the rule. #}
{%-   for protocol in protocols %}
{%-     set sources = source_ips|join(",") %}
{%-     set dports = ports|join(",") %}
-A INPUT -p {{ protocol }} -s {{ sources }} -m multiport --dports {{ dports }} -j ACCEPT -m comment --comment {{ rule }}
{%-   endfor %}
{%- endfor %}

{#- We're done applying rules. Anything else should be refused. It's polite 
    to reject rather than drop when possible. #}

{%- if salt['defaults.get']('prefer-reject') %}
-A INPUT -p tcp -j REJECT --reject-with tcp-reset
-A INPUT -j REJECT --reject-with icmp-host-prohibited
{%- endif %}
COMMIT
