{#- Please note that iptables-restore is annoyingly whitespace-sensitive and
    whitespace control is mandatory in this file. #}

{#- Most, but not all, rules work the same for iptables and ip6tables. For the
    exceptions, the variable 'ps' contains a dictionary of the appropriate options.
    This file expects to be provided with the variable 'family' as context, which
    determines which dictionary to use. 'family' may be ipv4 or ipv6 #}

{%- load_yaml as protocol_specifics %}
ipv4:
  icmp_protocol: icmp
  icmp_type_option: icmp-type
  iface_inet: inet
  rejection: icmp-host-prohibited

ipv6:
  icmp_protocol: ipv6-icmp
  icmp_type_option: icmpv6-type
  iface_inet: inet6
  rejection: icmp6-port-unreachable
{%- endload %}
{%- set ps = protocol_specifics[family] %}

{#- <-WHITESPACE NUKE-> -#}
# Generated by Salt Icewall state.
*filter

{#- set policy #}
{%- for chain in ["INPUT","FORWARD","OUTPUT"] %}
{%- set policy = salt['defaults.get']("policy:{}".format(chain)) %}
:{{ chain }} {{ policy }} [0:0]
{%- endfor %}

{#- Allow established connections and connections from localhost #}
-A INPUT -i lo -j ACCEPT
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

{#- set up ICMP #}
{%- set allowed_types = salt['defaults.get']('allow_icmp:{}'.format(family)) %}
{%- for type in allowed_types %}
-A INPUT -p {{ ps.icmp_protocol }} --{{ ps.icmp_type_option }} {{ type }} -j ACCEPT
{%- endfor %}

{#- Now we apply the rules from pillar. This is annoyingly complex. We are
    trying to allow the pillar to specify mappings of allowed-ips to
    allowed-ports in multiple different ways. ips may be specified
    as either an explicit list, or a pre-defined set, or a minion glob, or all
    at once. Ports may also be an explicit list or a pre-defined set. We build
    a list from each option given, concatenate them, and then iterate over the
    result to apply. #}

{%- for rule, settings in salt['defaults.get']('rules', {}).items() %}
{#-   Collect a list of ips allowed by this rule, as above. #}
{%-   set source_ips = settings.get('ips', []) %}
{%-   if "ipset" in settings %}
{%-     set ips = salt['defaults.get']('ipsets:' + settings.ipset, []) %}
{%-     do source_ips.extend(ips) %}
{%-   endif %}
{%-   if "minions" in settings %}
{%-     for minion in salt['mine.get'](settings.minions, 'network.interfaces').values() %}
{%-       do source_ips.append(minion['eth0'][ps.iface_inet][0]['address']) %}
{%-     endfor %}
{%-   endif %}

{#-   Now collect a list of ports allowed by this rule. #}
{%-   set ports = settings.get('ports', []) %}
{%-   if 'portset' in settings %}
{%-     set portset = salt['defaults.get']('portsets:' + settings.portset, []) %}
{%-     do ports.extend(portset) %}
{%-   endif %}

{#-   If the rule specifies a particular protocol, note that too. I'd like to
      come up with a clean way to support icmp here so the top block can be
      cut, but icmp types and tcp/udp ports use different syntax. #}
{%-   set protocols = settings.get('protocols', ['tcp','udp']) %}

{#-   Filter source_ips for ips that are valid for our current ip version family.
      I really wish there was a cleaner way to do this. #}
{%-   set valid_ips = [] %}
{%-   for ip in source_ips %}
{%-     if family == "ipv6" and ":" in ip %}
{%-       do valid_ips.append(ip) %}
{%-     elif family == "ipv4" and ("." in ip or ip == "0/0") %}
{%-       do valid_ips.append(ip) %}
{%-     endif %}
{%-   endfor %}

{#-   Now apply the rules. #}
{%-   for protocol in protocols %}
{%-     set sources = valid_ips|join(",") %}
{%-     set dports = ports|join(",") %}
{%-     if sources and dports %}
-A INPUT -p {{ protocol }} -s {{ sources }} -m multiport --dports {{ dports }} -j ACCEPT -m comment --comment {{ rule }}
{%-     endif %}
{%-   endfor %}
{%- endfor %}

{#- We're done applying rules. Anything else should be refused. It's polite
    to reject rather than drop when possible. #}

{%- if salt['defaults.get']('prefer-reject') %}
-A INPUT -p tcp -j REJECT --reject-with tcp-reset
-A INPUT -j REJECT --reject-with {{ ps.rejection }}
{%- endif %}
COMMIT
